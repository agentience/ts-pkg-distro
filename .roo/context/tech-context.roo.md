# Technical Context: QCubed to AWS Serverless Migration

## Current Technology Stack

### Backend

- **Language**: PHP (likely 7.2+)
- **Framework**: QCubed PHP Framework
  - Object-Relational Mapping (ORM)
  - Code generation for models and forms
  - Form state management
  - Template-based views
- **Database**: PostgreSQL
  - Relational database with 100+ tables
  - Mix of table types with various indexing strategies
  - Complex relationships between entities
- **Server**: Traditional web hosting
  - Apache or Nginx web server
  - PHP module/FastCGI

### Frontend

- **UI Framework**: QCubed UI components with jQuery
  - Server-rendered pages with jQuery enhancements
  - Form-based interface
  - QForms for interactive forms
- **JavaScript Libraries**:
  - jQuery core
  - jQuery UI for interface components
  - Custom JavaScript for specialized functionality
- **CSS/Styling**:
  - Likely custom CSS
  - Possible use of CSS frameworks (Bootstrap or similar)

### Infrastructure

- **Hosting**: Traditional web hosting
  - Shared or dedicated server
  - Not cloud-native
- **File Storage**: File system on the web server
- **Session Management**: PHP sessions
- **Authentication**: Custom session-based authentication
- **Deployment**: Manual deployment process

## Target Technology Stack with AWS Amplify

### AWS Amplify Framework

- **Development Framework**: AWS Amplify
  - Integrated toolchain for building serverless applications
  - CLI for resource provisioning and management
  - Library for client-side integration with AWS services
  - Generated code for common patterns and operations
  - Amplify Console for hosting and CI/CD

### Backend

- **API Layer**: AWS AppSync (GraphQL)
  - Strongly-typed GraphQL schema
  - Resolver mapping templates
  - Real-time subscriptions capability
  - Schema directives for authorization
  - Automatic documentation generation

- **Services**: AWS Lambda functions
  - Node.js runtime (TypeScript)
  - Domain-driven organization
  - Single-responsibility principle
  - Integration with AppSync resolvers
  - Generated from Amplify CLI

- **Database**: Amazon DynamoDB with single-table design
  - NoSQL with composite key structure
  - Global Secondary Indexes for access patterns
  - On-demand capacity model
  - Designed for access patterns, not entity relationships
  - OpenSearch Serverless to be added when advanced search is needed

- **File Storage**: Amazon S3
  - Document storage
  - Image assets
  - Static website hosting
  - Amplify Storage category for client integration

- **Workflow Orchestration**: AWS Step Functions
  - State machine definitions for complex workflows
  - Error handling and retry logic
  - Integration with Lambda functions

### Frontend

- **Framework**: React with Amplify UI
  - Component-based architecture
  - Functional components with hooks
  - Amplify UI components library
  - Generated API hooks from GraphQL schema

- **UI Library**: AWS Cloudscape Design System
  - Professionally designed components
  - Accessibility compliance
  - Responsive design patterns
  - Integration with Amplify UI

- **Build Tools**:
  - Amplify build process
  - ESLint and Prettier for code quality
  - Jest and React Testing Library for testing
  - Generated GraphQL operations

- **API Integration**:
  - Amplify API category
  - Generated hooks from GraphQL schema
  - Automatic authentication handling
  - Offline/online synchronization capabilities

### Authentication & Application-Level RBAC

- **User Management**: Amazon Cognito via Amplify Auth
  - User pools for authentication
  - Identity pools for AWS service access
  - MFA support
  - Social identity provider integration (if needed)

- **Role-Based Access Control**: 
  - Cognito groups for role membership
  - GraphQL directives for schema-level permissions
  - Custom resolvers for fine-grained access control
  - Role-based UI rendering
  - Organization-based data isolation

### Infrastructure & DevOps

- **Infrastructure as Code**: Amplify Configuration
  - CloudFormation templates generated by Amplify
  - Environment consistency through Amplify environments
  - Version-controlled infrastructure
  - Feature branch deployments

- **CI/CD Pipeline**:
  - Amplify Console for hosting and deployment
  - Multi-environment deployment (dev/test/prod)
  - Automated testing integration
  - Preview deployments for pull requests

- **Monitoring & Observability**:
  - CloudWatch for logs and metrics
  - X-Ray for distributed tracing
  - CloudWatch Alarms for alerts
  - Amplify Console analytics

## Technical Challenges and Approach

### Data Migration

1. **Schema Transformation**:
   - Converting relational schema to NoSQL
   - Designing efficient access patterns
   - Handling complex relationships
   - **Approach**: Start with core data model in GraphQL schema, evolve iteratively

2. **Data Volume**:
   - Managing large data volumes during migration
   - Ensuring data integrity and validation
   - Minimizing downtime during cutover
   - **Approach**: Phased data migration with validation checkpoints

3. **Historical Data**:
   - Preserving access to historical records
   - Maintaining reporting capabilities
   - Handling legacy data formats
   - **Approach**: Include historical data in initial DynamoDB model, add search capabilities later

### Business Logic Migration

1. **Workflow Complexity**:
   - Converting database-driven workflows to Step Functions
   - Preserving complex business rules
   - Ensuring accurate status transitions
   - **Approach**: Model workflows in AppSync and Step Functions, with resolver-enforced transitions

2. **Calculation Logic**:
   - Migrating specialized moisture testing calculations
   - Ensuring consistent results between systems
   - Validating calculation accuracy
   - **Approach**: Extract core calculation logic into reusable TypeScript libraries

3. **Form Logic**:
   - Converting server-side form validation to client-side
   - Preserving complex interdependencies in forms
   - Managing state for multi-step forms
   - **Approach**: Use GraphQL validation directives and custom React hooks

### Integration Points

1. **External Systems**:
   - Email notifications
   - Potential accounting system integrations
   - Report delivery mechanisms
   - **Approach**: Create dedicated Lambda functions for integration points

2. **File Management**:
   - Migration of existing documents and images
   - Secure access control for sensitive files
   - Efficient handling of photo uploads from the field
   - **Approach**: Use Amplify Storage category with role-based permissions

## Development Environment Requirements

### Local Development

- **Amplify Environment**:
  - Amplify CLI
  - Local mocking capabilities
  - Per-developer environments
  - Feature branch workflows

- **Backend**: Node.js development environment
  - TypeScript toolchain
  - AWS SDK
  - Amplify mock for local testing
  - Local AppSync testing

- **Frontend**: React development environment
  - TypeScript
  - React toolchain
  - Storybook for component development
  - Amplify UI components

### Test Environments

- **Integration Testing**:
  - Isolated AWS environment for integration tests
  - Test data generation scripts
  - API testing framework
- **Load Testing**:
  - Performance testing environment
  - Realistic load simulation
  - Benchmarking tools

### Production Environment

- **Multi-Region Considerations**:
  - Possible future multi-region deployment
  - Disaster recovery planning
  - Global distribution for static assets

## Technical Constraints

1. **AWS Service Limits**:
   - DynamoDB item size limits (400KB)
   - Lambda execution timeouts (15 minutes max)
   - AppSync payload limits and complexity limits
   - GraphQL query depth and complexity

2. **Compliance Requirements**:
   - Data retention policies
   - Security requirements
   - Audit trail needs
   - Multi-tenant data isolation

3. **Performance Requirements**:
   - Page load time expectations
   - API response time targets
   - Report generation speed requirements
   - GraphQL query optimization

## Technical Risks and Mitigations

1. **DynamoDB Design Risks**:
   - Access pattern limitations
   - Query complexity challenges
   - Potential hot partition issues
   - **Mitigation**: Careful access pattern design, phased approach to OpenSearch

2. **GraphQL Complexity**:
   - Schema design challenges
   - Resolver performance
   - N+1 query problems
   - **Mitigation**: Optimized resolvers, query complexity monitoring

3. **Lambda Cold Start**:
   - Performance impact of cold starts
   - Strategies for minimizing cold start delays
   - Warming solutions if needed
   - **Mitigation**: Provisioned concurrency for critical functions

4. **API Latency**:
   - Network latency considerations
   - Edge locations configuration
   - Caching strategies
   - **Mitigation**: AppSync caching, CDN optimization

5. **Frontend Performance**:
   - Bundle size optimization
   - Code splitting strategy
   - Performance monitoring approach
   - **Mitigation**: Amplify optimization features, code splitting

## Implementation Strategy

1. **Phased Approach**:
   - Initial implementation using DynamoDB single-table design
   - Focus on core business functionality first
   - Add OpenSearch Serverless later for advanced search
   - Iterative enhancements to the UI and UX

2. **Development Acceleration with Amplify**:
   - Use generated code for common patterns
   - Leverage Amplify's built-in authentication and storage
   - AppSync for robust GraphQL API
   - Multiple environments for feature development

3. **RBAC Implementation Path**:
   - Start with basic role definitions in Cognito groups
   - Implement organization isolation at the database level
   - Add GraphQL schema directives for permissions
   - Develop UI components that respect user roles

4. **Monitoring and Optimization**:
   - Implement monitoring from day one
   - Regular performance reviews
   - Cost analysis and optimization
   - User experience feedback loop
